var N = null;var searchIndex = {};
searchIndex["glob"]={"doc":"Support for matching file paths against Unix shell style patterns.","items":[[3,"Paths","glob","An iterator that yields `Path`s from the filesystem that match a particular pattern.",N,N],[3,"GlobError","","A glob iteration error.",N,N],[3,"PatternError","","A pattern parsing error.",N,N],[12,"pos","","The approximate character index of where the error occurred.",0,N],[12,"msg","","A message describing the error.",0,N],[3,"Pattern","","A compiled Unix shell style pattern.",N,N],[3,"MatchOptions","","Configuration options to modify the behaviour of `Pattern::matches_with(..)`.",N,N],[12,"case_sensitive","","Whether or not patterns should be matched in a case-sensitive manner. This currently only considers upper/lower case relationships between ASCII characters, but in future this might be extended to work with Unicode.",1,N],[12,"require_literal_separator","","Whether or not path-component separator characters (e.g. `/` on Posix) must be matched by a literal `/`, rather than by `*` or `?` or `[...]`.",1,N],[12,"require_literal_leading_dot","","Whether or not paths that contain components that start with a `.` will require that `.` appears literally in the pattern; `*`, `?`, `**`, or `[...]` will not match. This is useful because such files are conventionally considered hidden on Unix systems and it might be desirable to skip them when listing files.",1,N],[5,"glob","","Return an iterator that produces all the `Path`s that match the given pattern using default match options, which may be absolute or relative to the current working directory.",N,[[["str"]],["result",["paths","patternerror"]]]],[5,"glob_with","","Return an iterator that produces all the `Path`s that match the given pattern using the specified match options, which may be absolute or relative to the current working directory.",N,[[["str"],["matchoptions"]],["result",["paths","patternerror"]]]],[6,"GlobResult","","An alias for a glob iteration result.",N,N],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"path","","The Path that the error corresponds to.",2,[[["self"]],["path"]]],[11,"error","","The error in question.",2,[[["self"]],["error"]]],[11,"into_error","","Consumes self, returning the raw underlying `io::Error`",2,[[["self"]],["error"]]],[11,"description","","",2,[[["self"]],["str"]]],[11,"cause","","",2,[[["self"]],["option",["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"next","","",3,[[["self"]],["option",["globresult"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"description","","",0,[[["self"]],["str"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"clone","","",4,[[["self"]],["pattern"]]],[11,"eq","","",4,[[["self"],["pattern"]],["bool"]]],[11,"ne","","",4,[[["self"],["pattern"]],["bool"]]],[11,"partial_cmp","","",4,[[["self"],["pattern"]],["option",["ordering"]]]],[11,"lt","","",4,[[["self"],["pattern"]],["bool"]]],[11,"le","","",4,[[["self"],["pattern"]],["bool"]]],[11,"gt","","",4,[[["self"],["pattern"]],["bool"]]],[11,"ge","","",4,[[["self"],["pattern"]],["bool"]]],[11,"cmp","","",4,[[["self"],["pattern"]],["ordering"]]],[11,"hash","","",4,N],[11,"default","","",4,[[],["pattern"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"from_str","","",4,[[["str"]],["result",["pattern","patternerror"]]]],[11,"new","","This function compiles Unix shell style patterns.",4,[[["str"]],["result",["pattern","patternerror"]]]],[11,"escape","","Escape metacharacters within the given string by surrounding them in brackets. The resulting string will, when compiled into a `Pattern`, match the input string and nothing else.",4,[[["str"]],["string"]]],[11,"matches","","Return if the given `str` matches this `Pattern` using the default match options (i.e. `MatchOptions::new()`).",4,[[["self"],["str"]],["bool"]]],[11,"matches_path","","Return if the given `Path`, when converted to a `str`, matches this `Pattern` using the default match options (i.e. `MatchOptions::new()`).",4,[[["self"],["path"]],["bool"]]],[11,"matches_with","","Return if the given `str` matches this `Pattern` using the specified match options.",4,[[["self"],["str"],["matchoptions"]],["bool"]]],[11,"matches_path_with","","Return if the given `Path`, when converted to a `str`, matches this `Pattern` using the specified match options.",4,[[["self"],["path"],["matchoptions"]],["bool"]]],[11,"as_str","","Access the original glob pattern.",4,[[["self"]],["str"]]],[11,"clone","","",1,[[["self"]],["matchoptions"]]],[11,"eq","","",1,[[["self"],["matchoptions"]],["bool"]]],[11,"ne","","",1,[[["self"],["matchoptions"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["matchoptions"]],["option",["ordering"]]]],[11,"lt","","",1,[[["self"],["matchoptions"]],["bool"]]],[11,"le","","",1,[[["self"],["matchoptions"]],["bool"]]],[11,"gt","","",1,[[["self"],["matchoptions"]],["bool"]]],[11,"ge","","",1,[[["self"],["matchoptions"]],["bool"]]],[11,"cmp","","",1,[[["self"],["matchoptions"]],["ordering"]]],[11,"hash","","",1,N],[11,"default","","",1,[[],["matchoptions"]]],[11,"new","","Constructs a new `MatchOptions` with default field values. This is used when calling functions that do not take an explicit `MatchOptions` parameter.",1,[[],["matchoptions"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into_iter","","",3,[[["self"]],["i"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]]],"paths":[[3,"PatternError"],[3,"MatchOptions"],[3,"GlobError"],[3,"Paths"],[3,"Pattern"]]};
initSearch(searchIndex);
